<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Prox and gradient · ProximalOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ProximalOperators.jl logo"/></a><h1>ProximalOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li><a class="toctext" href="calculus.html">Calculus rules</a></li><li class="current"><a class="toctext" href="operators.html">Prox and gradient</a><ul class="internal"><li><a class="toctext" href="#Complex-and-matrix-variables-1">Complex and matrix variables</a></li><li><a class="toctext" href="#Multiple-variable-blocks-1">Multiple variable blocks</a></li></ul></li><li><a class="toctext" href="demos.html">Demos</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="operators.html">Prox and gradient</a></li></ul><a class="edit-page" href="https://github.com/kul-forbes/ProximalOperators.jl/blob/master/docs/src/operators.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Prox and gradient</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Prox-and-gradient-1" href="#Prox-and-gradient-1">Prox and gradient</a></h1><p>The following methods allow to evaluate the proximal mapping (and gradient, when defined) of mathematical functions, which are constructed according to what described in <a href="functions.html#Functions-1">Functions</a> and <a href="calculus.html#Calculus-rules-1">Calculus rules</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProximalOperators.prox" href="#ProximalOperators.prox"><code>ProximalOperators.prox</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Proximal mapping</strong></p><pre><code class="language-none">y, fy = prox(f, x, γ=1.0)</code></pre><p>Computes</p><div>\[y = \mathrm{prox}_{\gamma f}(x) = \arg\min_z \left\{ f(z) + \tfrac{1}{2\gamma}\|z-x\|^2 \right\}.\]</div><p>Return values:</p><ul><li><p><code>y</code>: the proximal point <span>$y$</span></p></li><li><p><code>fy</code>: the value <span>$f(y)$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/ProximalOperators.jl/blob/a5954fb31d6d970af93045bedb976fbd7027d689/src/ProximalOperators.jl#L116-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProximalOperators.prox!" href="#ProximalOperators.prox!"><code>ProximalOperators.prox!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Proximal mapping (in-place)</strong></p><pre><code class="language-none">fy = prox!(y, f, x, γ=1.0)</code></pre><p>Computes</p><div>\[y = \mathrm{prox}_{\gamma f}(x) = \arg\min_z \left\{ f(z) + \tfrac{1}{2\gamma}\|z-x\|^2 \right\}.\]</div><p>The resulting point <span>$y$</span> is written to the (pre-allocated) array <code>y</code>, which must have the same shape/size as <code>x</code>.</p><p>Return values:</p><ul><li><p><code>fy</code>: the value <span>$f(y)$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/ProximalOperators.jl/blob/a5954fb31d6d970af93045bedb976fbd7027d689/src/ProximalOperators.jl#L136-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.LinAlg.gradient" href="#Base.LinAlg.gradient"><code>Base.LinAlg.gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Gradient mapping</strong></p><pre><code class="language-none">gradfx, fx = gradient(f, x)</code></pre><p>Computes the gradient (and value) of <span>$f$</span> at <span>$x$</span>. If <span>$f$</span> is only <em>subdifferentiable</em> at <span>$x$</span>, then return a subgradient instead.</p><p>Return values:</p><ul><li><p><code>gradfx</code>: the (sub)gradient of <span>$f$</span> at <span>$x$</span></p></li><li><p><code>fx</code>: the value <span>$f(x)$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/ProximalOperators.jl/blob/a5954fb31d6d970af93045bedb976fbd7027d689/src/ProximalOperators.jl#L153-L163">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ProximalOperators.gradient!" href="#ProximalOperators.gradient!"><code>ProximalOperators.gradient!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><strong>Gradient mapping (in-place)</strong></p><pre><code class="language-none">gradient!(gradfx, f, x)</code></pre><p>Writes <span>$\nabla f(x)$</span> to <code>gradfx</code>, which must be pre-allocated and have the same shape/size as <code>x</code>. If <span>$f$</span> is only <em>subdifferentiable</em> at <span>$x$</span>, then writes a subgradient instead.</p><p>Return values:</p><ul><li><p><code>fx</code>: the value <span>$f(x)$</span></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/ProximalOperators.jl/blob/a5954fb31d6d970af93045bedb976fbd7027d689/src/ProximalOperators.jl#L171-L180">source</a></section><h2><a class="nav-anchor" id="Complex-and-matrix-variables-1" href="#Complex-and-matrix-variables-1">Complex and matrix variables</a></h2><p>The proximal mapping is usually discussed in the case of functions over <span>$\mathbb{R}^n$</span>. However, by adapting the inner product <span>$\langle\cdot,\cdot\rangle$</span> and associated norm <span>$\|\cdot\|$</span> adopted in its definition, one can extend the concept to functions over more general spaces. When functions of unidimensional arrays (vectors) are concerned, the standard Euclidean product and norm are used in defining <a href="operators.html#ProximalOperators.prox"><code>prox</code></a> (therefore <a href="operators.html#ProximalOperators.prox!"><code>prox!</code></a>, but also <a href="operators.html#Base.LinAlg.gradient"><code>gradient</code></a> and <a href="operators.html#ProximalOperators.gradient!"><code>gradient!</code></a>). This are the inner product and norm which are computed by <code>dot</code> and <code>norm</code> in Julia.</p><p>When bidimensional, tridimensional (matrices and tensors) and higher dimensional arrays are concerned, then the definitions of proximal mapping and gradient are naturally extended by considering the appropriate inner product. For <span>$k$</span>-dimensional arrays, of size <span>$n_1 \times n_2 \times \ldots \times n_k$</span>, we consider the inner product</p><div>\[\langle A, B \rangle = \sum_{i_1,\ldots,i_k} A_{i_1,\ldots,i_k} \cdot B_{i_1,\ldots,i_k}\]</div><p>which reduces to the usual Euclidean product in case of unidimensional arrays, and to the <em>trace product</em> <span>$\langle A, B \rangle = \mathrm{tr}(A^\top B)$</span> in the case of matrices (bidimensional arrays). This inner product, and the associated norm, are the ones computed by <code>vecdot</code> and <code>vecnorm</code> in Julia.</p><h2><a class="nav-anchor" id="Multiple-variable-blocks-1" href="#Multiple-variable-blocks-1">Multiple variable blocks</a></h2><p>By combining functions together through <a href="calculus.html#ProximalOperators.SeparableSum"><code>SeparableSum</code></a>, the resulting function will have multiple inputs, <em>i.e.</em>, it will be defined over the <em>Cartesian product</em> of the domains of the individual functions. To represent elements (points) of such product space, here we use Julia&#39;s <code>Tuple</code> objects.</p><p><strong>Example.</strong> Suppose that the following function needs to be represented:</p><div>\[f(x, Y) = \|x\|_1 + \|Y\|_*,\]</div><p>that is, the sum of the <span>$L_1$</span> norm of some vector <span>$x$</span> and the nuclear norm (the sum of the singular values) of some matrix <span>$Y$</span>. This is accomplished as follows:</p><pre><code class="language-example">using ProximalOperators
f = SeparableSum(NormL1(), NuclearNorm());</code></pre><p>Now, function <code>f</code> is defined over <em>pairs</em> of appropriate <code>Array</code> objects. Likewise, the <a href="operators.html#ProximalOperators.prox"><code>prox</code></a> method will take pairs of <code>Array</code>s as inputs, and return pairs of <code>Array</code>s as output:</p><pre><code class="language-example">x = randn(10); # some random vector
Y = randn(20, 30); # some random matrix
f_xY = f((x, Y)); # evaluates f at (x, Y)
(u, V), f_uV = prox(f, (x, Y), 1.3); # computes prox at (x, Y)</code></pre><p>The same holds for the separable sum of more than two functions, in which case &quot;pairs&quot; are to be replaced with <code>Tuple</code>s of the appropriate length.</p><footer><hr/><a class="previous" href="calculus.html"><span class="direction">Previous</span><span class="title">Calculus rules</span></a><a class="next" href="demos.html"><span class="direction">Next</span><span class="title">Demos</span></a></footer></article></body></html>
